// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: engagement.sql

package database

import (
	"context"
)

const getEventEngagementBySlug = `-- name: GetEventEngagementBySlug :many
SELECT 
    s.slug,
    COUNT(DISTINCT r.session_id) as sessions,
    COALESCE(COUNT(r.session_id), 0) as total_votes
FROM slugs s
LEFT JOIN responses r ON r.slug = s.slug
    AND r.question_id IN (SELECT question_id FROM questions WHERE questions.event_id = $1)
WHERE s.event_id = $1
GROUP BY s.slug
ORDER BY s.slug
`

type GetEventEngagementBySlugRow struct {
	Slug       string      `json:"slug"`
	Sessions   int64       `json:"sessions"`
	TotalVotes interface{} `json:"total_votes"`
}

func (q *Queries) GetEventEngagementBySlug(ctx context.Context, eventID string) ([]GetEventEngagementBySlugRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventEngagementBySlug, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventEngagementBySlugRow{}
	for rows.Next() {
		var i GetEventEngagementBySlugRow
		if err := rows.Scan(&i.Slug, &i.Sessions, &i.TotalVotes); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventEngagementTotal = `-- name: GetEventEngagementTotal :one

SELECT 
    COUNT(DISTINCT r.session_id) as sessions,
    COUNT(*) as total_votes
FROM responses r
JOIN questions q ON q.question_id = r.question_id
WHERE q.event_id = $1
`

type GetEventEngagementTotalRow struct {
	Sessions   int64 `json:"sessions"`
	TotalVotes int64 `json:"total_votes"`
}

// Event-Level Engagement Queries
func (q *Queries) GetEventEngagementTotal(ctx context.Context, eventID string) (GetEventEngagementTotalRow, error) {
	row := q.db.QueryRowContext(ctx, getEventEngagementTotal, eventID)
	var i GetEventEngagementTotalRow
	err := row.Scan(&i.Sessions, &i.TotalVotes)
	return i, err
}

const getEventRetentionBySlug = `-- name: GetEventRetentionBySlug :many
SELECT 
    s.slug,
    q.question_id,
    q.big_text,
    COUNT(DISTINCT r.session_id) as sessions_answered
FROM slugs s
CROSS JOIN questions q
LEFT JOIN responses r ON r.question_id = q.question_id AND r.slug = s.slug
WHERE s.event_id = $1 AND q.event_id = $1
GROUP BY s.slug, q.question_id, q.big_text
ORDER BY s.slug, q.question_id ASC
`

type GetEventRetentionBySlugRow struct {
	Slug             string `json:"slug"`
	QuestionID       string `json:"question_id"`
	BigText          string `json:"big_text"`
	SessionsAnswered int64  `json:"sessions_answered"`
}

func (q *Queries) GetEventRetentionBySlug(ctx context.Context, eventID string) ([]GetEventRetentionBySlugRow, error) {
	rows, err := q.db.QueryContext(ctx, getEventRetentionBySlug, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetEventRetentionBySlugRow{}
	for rows.Next() {
		var i GetEventRetentionBySlugRow
		if err := rows.Scan(
			&i.Slug,
			&i.QuestionID,
			&i.BigText,
			&i.SessionsAnswered,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionEngagementBySlug = `-- name: GetQuestionEngagementBySlug :many
SELECT 
    s.slug,
    COUNT(DISTINCT r.session_id) as sessions,
    COALESCE(COUNT(r.session_id), 0) as total_votes,
    COALESCE(SUM(CASE WHEN r.choice = 'a' THEN 1 ELSE 0 END), 0) as votes_a,
    COALESCE(SUM(CASE WHEN r.choice = 'b' THEN 1 ELSE 0 END), 0) as votes_b
FROM slugs s
LEFT JOIN responses r ON r.slug = s.slug AND r.question_id = $1
WHERE s.event_id = (SELECT event_id FROM questions WHERE question_id = $1)
GROUP BY s.slug
ORDER BY s.slug
`

type GetQuestionEngagementBySlugRow struct {
	Slug       string      `json:"slug"`
	Sessions   int64       `json:"sessions"`
	TotalVotes interface{} `json:"total_votes"`
	VotesA     interface{} `json:"votes_a"`
	VotesB     interface{} `json:"votes_b"`
}

func (q *Queries) GetQuestionEngagementBySlug(ctx context.Context, questionID string) ([]GetQuestionEngagementBySlugRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionEngagementBySlug, questionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionEngagementBySlugRow{}
	for rows.Next() {
		var i GetQuestionEngagementBySlugRow
		if err := rows.Scan(
			&i.Slug,
			&i.Sessions,
			&i.TotalVotes,
			&i.VotesA,
			&i.VotesB,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionEngagementTotal = `-- name: GetQuestionEngagementTotal :one

SELECT 
    COUNT(DISTINCT session_id) as sessions,
    COUNT(*) as total_votes,
    COALESCE(SUM(CASE WHEN choice = 'a' THEN 1 ELSE 0 END), 0) as votes_a,
    COALESCE(SUM(CASE WHEN choice = 'b' THEN 1 ELSE 0 END), 0) as votes_b
FROM responses
WHERE question_id = $1
`

type GetQuestionEngagementTotalRow struct {
	Sessions   int64       `json:"sessions"`
	TotalVotes int64       `json:"total_votes"`
	VotesA     interface{} `json:"votes_a"`
	VotesB     interface{} `json:"votes_b"`
}

// Question-Level Engagement Queries
func (q *Queries) GetQuestionEngagementTotal(ctx context.Context, questionID string) (GetQuestionEngagementTotalRow, error) {
	row := q.db.QueryRowContext(ctx, getQuestionEngagementTotal, questionID)
	var i GetQuestionEngagementTotalRow
	err := row.Scan(
		&i.Sessions,
		&i.TotalVotes,
		&i.VotesA,
		&i.VotesB,
	)
	return i, err
}
